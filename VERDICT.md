# Vulnerability Report Verdict: Buffer Overflow in WebSocket Handshake

## Verdict: INVALID

The claimed vulnerability is **not real**. The report contains multiple fundamental misunderstandings of the code.

## What the Report Claims

> A buffer overflow vulnerability exists in curl's WebSocket handshake implementation at lib/ws.c line 1287. A malicious WebSocket server could send a crafted handshake response that overflows a fixed-size buffer during the Sec-WebSocket-Accept header validation, leading to potential remote code execution.

## What the Code Actually Does at Line 1287

Line 1287 of `lib/ws.c` is inside the function `Curl_ws_request()` (lines 1243-1298), which generates the **client's outgoing WebSocket upgrade request** — not the server response validation. The specific line is:

```c
curlx_strcopy(keyval, sizeof(keyval), randstr, randlen);
```

This copies the client's own base64-encoded random `Sec-WebSocket-Key` value into a local stack buffer `keyval[40]`. The data copied here is **generated entirely by the client** from `Curl_rand()` — a malicious server has zero influence on this value.

## Why the Claimed Overflow Cannot Happen

### 1. The buffer is not influenced by server data

The `keyval[40]` buffer at line 1250 stores the base64 encoding of 16 random bytes generated by the client itself (`Curl_rand(data, rand, sizeof(rand))` at line 1276). The server plays no role in this code path — `Curl_ws_request()` runs before any server response is received.

### 2. The output size is deterministic and safe

Base64-encoding 16 bytes always produces exactly 24 characters. The buffer is 40 bytes. 24 < 40, so the copy always succeeds safely.

### 3. Multiple layers of bounds protection exist

Even if the base64 output were somehow larger than expected:

- **Lines 1282-1286**: An explicit bounds check `if(randlen >= sizeof(keyval))` returns an error before the copy.
- **`curlx_strcopy()` itself**: The function checks `if(slen < dsize)` and refuses to copy if the source doesn't fit, null-terminating the buffer instead.

### 4. Sec-WebSocket-Accept is never validated at all

The report claims the overflow occurs "during the Sec-WebSocket-Accept header validation." In reality, **curl does not validate the Sec-WebSocket-Accept response header**. This is explicitly documented as future work in `docs/internals/WEBSOCKET.md`:

> ## Future work
> - Verify the Sec-WebSocket-Accept response. It requires a sha-1 function.

The `Curl_ws_accept()` function (lines 1314-1449) contains only comments about this validation (lines 1357-1374) but no actual implementation. The server's `Sec-WebSocket-Accept` header value is never read into any buffer for validation purposes.

### 5. Wrong code path identified

The report conflates the client-side key generation (`Curl_ws_request()`) with server-side response handling (`Curl_ws_accept()`). These are separate functions serving different purposes:
- `Curl_ws_request()` — builds the HTTP upgrade request with `Sec-WebSocket-Key`
- `Curl_ws_accept()` — handles the 101 response and sets up the WebSocket connection

## Empirical Verification

- Built curl 8.19.0-DEV with debug mode and ran WebSocket tests 2700-2705 under valgrind.
- All tests passed with zero memory errors reported by valgrind.
- The WebSocket handshake code path executes correctly with no buffer overflows.

## Summary of Why the Report is Invalid

| Claim | Reality |
|---|---|
| Line 1287 handles Sec-WebSocket-Accept validation | Line 1287 is in `Curl_ws_request()`, which generates the client request |
| A malicious server can overflow the buffer | The buffer contains client-generated data; server has no influence |
| Fixed-size buffer overflows during header validation | The buffer is 40 bytes, the data is always 24 bytes, and bounds are checked |
| Sec-WebSocket-Accept is validated | It is not validated at all (documented as future work) |
